package report

import (
	"context"
	"errors"
	"fmt"
	"html/template"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"passive-rec/internal/config"
)

// SinkFiles describe the location of the files generated by the sink.
type SinkFiles struct {
	Domains string
	Routes  string
	Certs   string
	Meta    string
}

// DefaultSinkFiles returns the expected sink file paths within outDir.
func DefaultSinkFiles(outDir string) SinkFiles {
	return SinkFiles{
		Domains: filepath.Join(outDir, "domains.passive"),
		Routes:  filepath.Join(outDir, "routes.passive"),
		Certs:   filepath.Join(outDir, "certs.passive"),
		Meta:    filepath.Join(outDir, "meta.passive"),
	}
}

// Generate reads the passive sink files and renders an HTML report in cfg.OutDir.
func Generate(ctx context.Context, cfg *config.Config, files SinkFiles) error {
	if cfg == nil {
		return errors.New("report: missing config")
	}
	if err := ctx.Err(); err != nil {
		return err
	}

	domains, err := readLines(ctx, files.Domains)
	if err != nil {
		return fmt.Errorf("report: domains: %w", err)
	}
	routes, err := readLines(ctx, files.Routes)
	if err != nil {
		return fmt.Errorf("report: routes: %w", err)
	}
	certs, err := readLines(ctx, files.Certs)
	if err != nil {
		return fmt.Errorf("report: certs: %w", err)
	}
	meta, err := readLines(ctx, files.Meta)
	if err != nil {
		return fmt.Errorf("report: meta: %w", err)
	}

	domainStats := buildDomainStats(domains)
	routeStats := buildRouteStats(routes)
	certStats := buildCertStats(certs)

	data := reportData{
		Target:      cfg.Target,
		OutDir:      cfg.OutDir,
		GeneratedAt: time.Now().Format(time.RFC3339),
		Overview: overviewStats{
			TotalArtifacts:      domainStats.Total + routeStats.Total + certStats.Total,
			UniqueDomains:       domainStats.Unique,
			UniqueHosts:         routeStats.UniqueHosts,
			UniqueCertificates:  certStats.Unique,
			SecureRoutesPercent: routeStats.SecurePercentage,
		},
		Domains:      domainStats,
		Routes:       routeStats,
		Certificates: certStats,
		Meta:         meta,
	}

	reportPath := filepath.Join(cfg.OutDir, "report.html")
	if err := ctx.Err(); err != nil {
		return err
	}

	f, err := os.Create(reportPath)
	if err != nil {
		return fmt.Errorf("report: create %q: %w", reportPath, err)
	}
	defer f.Close()

	if err := reportTmpl.Execute(f, data); err != nil {
		return fmt.Errorf("report: render: %w", err)
	}
	return nil
}

type countItem struct {
	Name  string
	Count int
}

type domainStats struct {
	Total             int
	Unique            int
	UniqueRegistrable int
	AverageLabels     float64
	TopRegistrable    []countItem
	LabelHistogram    []countItem
}

type routeStats struct {
	Total            int
	UniqueHosts      int
	UniqueSchemes    int
	SecurePercentage float64
	TopHosts         []countItem
	SchemeHistogram  []countItem
	DepthHistogram   []countItem
	AveragePathDepth float64
}

type certStats struct {
	Total             int
	Unique            int
	UniqueRegistrable int
	TopRegistrable    []countItem
}

type overviewStats struct {
	TotalArtifacts      int
	UniqueDomains       int
	UniqueHosts         int
	UniqueCertificates  int
	SecureRoutesPercent float64
}

type reportData struct {
	Target       string
	OutDir       string
	GeneratedAt  string
	Overview     overviewStats
	Domains      domainStats
	Routes       routeStats
	Certificates certStats
	Meta         []string
}

const topN = 10

var reportTmpl = template.Must(template.New("report").Funcs(template.FuncMap{
	"hasData": func(items []countItem) bool { return len(items) > 0 },
}).Parse(reportTemplate))

func readLines(ctx context.Context, path string) ([]string, error) {
	if path == "" {
		return nil, nil
	}
	if err := ctx.Err(); err != nil {
		return nil, err
	}
	data, err := os.ReadFile(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil, nil
		}
		return nil, err
	}
	contents := strings.TrimSpace(string(data))
	if contents == "" {
		return nil, nil
	}
	lines := strings.Split(contents, "\n")
	for i, ln := range lines {
		lines[i] = strings.TrimSpace(ln)
	}
	return lines, nil
}

func buildDomainStats(domains []string) domainStats {
	stats := domainStats{Total: len(domains)}
	if len(domains) == 0 {
		return stats
	}
	registrableCounts := make(map[string]int)
	labelHistogram := make(map[string]int)
	uniqueDomains := make(map[string]struct{})
	uniqueRegistrable := make(map[string]struct{})
	var totalLabels int
	for _, d := range domains {
		if d == "" {
			continue
		}
		uniqueDomains[strings.ToLower(d)] = struct{}{}
		registrable := registrableDomain(d)
		uniqueRegistrable[registrable] = struct{}{}
		registrableCounts[registrable]++
		levels := strings.Count(d, ".") + 1
		labelKey := fmt.Sprintf("%d niveles", levels)
		labelHistogram[labelKey]++
		totalLabels += levels
	}
	stats.TopRegistrable = topItems(registrableCounts, topN)
	stats.LabelHistogram = topItems(labelHistogram, len(labelHistogram))
	stats.Unique = len(uniqueDomains)
	stats.UniqueRegistrable = len(uniqueRegistrable)
	if stats.Total > 0 {
		stats.AverageLabels = float64(totalLabels) / float64(stats.Total)
	}
	return stats
}

func buildCertStats(certs []string) certStats {
	stats := certStats{Total: len(certs)}
	if len(certs) == 0 {
		return stats
	}
	registrableCounts := make(map[string]int)
	uniqueCerts := make(map[string]struct{})
	uniqueRegistrable := make(map[string]struct{})
	for _, c := range certs {
		if c == "" {
			continue
		}
		uniqueCerts[strings.ToLower(c)] = struct{}{}
		registrable := registrableDomain(c)
		uniqueRegistrable[registrable] = struct{}{}
		registrableCounts[registrable]++
	}
	stats.TopRegistrable = topItems(registrableCounts, topN)
	stats.Unique = len(uniqueCerts)
	stats.UniqueRegistrable = len(uniqueRegistrable)
	return stats
}

func buildRouteStats(routes []string) routeStats {
	stats := routeStats{Total: len(routes)}
	if len(routes) == 0 {
		return stats
	}
	hostCounts := make(map[string]int)
	schemeHistogram := make(map[string]int)
	depthHistogram := make(map[string]int)
	var totalDepth int
	uniqueHosts := make(map[string]struct{})
	httpsCount := 0
	for _, raw := range routes {
		trimmed := strings.TrimSpace(raw)
		if trimmed == "" {
			continue
		}
		fields := strings.Fields(trimmed)
		candidate := trimmed
		if len(fields) > 0 {
			candidate = fields[0]
		}
		u, err := url.Parse(candidate)
		if err != nil {
			continue
		}
		host := strings.TrimSpace(u.Host)
		if host == "" {
			host = "(sin host)"
		}
		loweredHost := strings.ToLower(host)
		hostCounts[loweredHost]++
		uniqueHosts[loweredHost] = struct{}{}
		scheme := strings.ToLower(u.Scheme)
		if scheme == "" {
			scheme = "(vacío)"
		}
		schemeHistogram[scheme]++
		if scheme == "https" {
			httpsCount++
		}
		path := strings.Trim(u.Path, "/")
		depth := 0
		if path != "" {
			depth = len(strings.Split(path, "/"))
		}
		depthKey := fmt.Sprintf("%d segmentos", depth)
		depthHistogram[depthKey]++
		totalDepth += depth
	}
	stats.TopHosts = topItems(hostCounts, topN)
	stats.SchemeHistogram = topItems(schemeHistogram, len(schemeHistogram))
	stats.DepthHistogram = topItems(depthHistogram, len(depthHistogram))
	stats.AveragePathDepth = float64(totalDepth)
	stats.UniqueHosts = len(uniqueHosts)
	stats.UniqueSchemes = len(schemeHistogram)
	if stats.Total > 0 {
		stats.AveragePathDepth = stats.AveragePathDepth / float64(stats.Total)
		stats.SecurePercentage = (float64(httpsCount) / float64(stats.Total)) * 100
	}
	return stats
}

func registrableDomain(domain string) string {
	parts := strings.FieldsFunc(domain, func(r rune) bool { return r == '.' })
	if len(parts) <= 1 {
		return strings.ToLower(strings.TrimSpace(domain))
	}
	last := parts[len(parts)-1]
	secondLast := parts[len(parts)-2]
	if secondLast == "" {
		return strings.ToLower(last)
	}
	return strings.ToLower(secondLast + "." + last)
}

func topItems(counts map[string]int, n int) []countItem {
	if len(counts) == 0 || n == 0 {
		return nil
	}
	items := make([]countItem, 0, len(counts))
	for name, count := range counts {
		items = append(items, countItem{Name: name, Count: count})
	}
	sort.Slice(items, func(i, j int) bool {
		if items[i].Count == items[j].Count {
			return items[i].Name < items[j].Name
		}
		return items[i].Count > items[j].Count
	})
	if n > len(items) {
		n = len(items)
	}
	return items[:n]
}

const reportTemplate = `<!DOCTYPE html>
<html lang="es">
<head>
        <meta charset="utf-8">
        <title>Informe passive-rec</title>
        <style>
                :root {
                        color-scheme: light;
                }
                body { font-family: "Inter", "Segoe UI", Arial, sans-serif; margin: 2.5rem; background: #f1f5f9; color: #1f2937; }
                h1, h2, h3 { color: #111827; margin-top: 0; }
                header { margin-bottom: 2rem; }
                section { margin-bottom: 2rem; padding: 1.5rem; background: #ffffff; border-radius: 12px; box-shadow: 0 15px 35px rgba(15, 23, 42, 0.08); }
                table { border-collapse: collapse; margin-bottom: 1.5rem; width: 100%; background: white; border-radius: 8px; overflow: hidden; }
                th, td { border: 1px solid #e2e8f0; padding: 0.65rem 0.9rem; text-align: left; }
                th { background: #0f172a; color: #f8fafc; text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.82rem; }
                ul { padding-left: 1.5rem; }
                .muted { color: #64748b; }
                .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; margin-top: 1rem; }
                .card { border: 1px solid #e2e8f0; border-radius: 10px; padding: 1rem; background: linear-gradient(135deg, rgba(148, 163, 184, 0.12), rgba(148, 163, 184, 0)); }
                .metric { font-size: 2rem; font-weight: 600; color: #0f172a; margin: 0.25rem 0; }
                .subtext { font-size: 0.9rem; color: #475569; margin: 0; }
                .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; }
        </style>
</head>
<body>
        <header>
                <h1>Informe de passive-rec</h1>
                <p><strong>Objetivo:</strong> {{.Target}}</p>
                <p><strong>Directorio de salida:</strong> {{.OutDir}}</p>
                <p class="muted">Generado: {{.GeneratedAt}}</p>
        </header>

        <section>
                <h2>Resumen ejecutivo</h2>
                <p class="subtext">Vista rápida de los hallazgos más relevantes para priorizar acciones.</p>
                <div class="cards">
                        <div class="card">
                                <h3>Total de artefactos procesados</h3>
                                <p class="metric">{{.Overview.TotalArtifacts}}</p>
                                <p class="subtext">Entradas combinadas de dominios, rutas y certificados.</p>
                        </div>
                        <div class="card">
                                <h3>Dominios únicos</h3>
                                <p class="metric">{{.Overview.UniqueDomains}}</p>
                                <p class="subtext">Incluye {{.Domains.UniqueRegistrable}} dominios registrables distintos.</p>
                        </div>
                        <div class="card">
                                <h3>Hosts únicos en rutas</h3>
                                <p class="metric">{{.Overview.UniqueHosts}}</p>
                                <p class="subtext">Cobertura sobre {{.Routes.UniqueSchemes}} esquemas de servicio.</p>
                        </div>
                        <div class="card">
                                <h3>Certificados únicos</h3>
                                <p class="metric">{{.Overview.UniqueCertificates}}</p>
                                <p class="subtext">{{printf "%.1f" .Overview.SecureRoutesPercent}}% de las rutas usan HTTPS.</p>
                        </div>
                </div>
        </section>

        <section>
                <h2>Dominios</h2>
                <div class="grid">
                        <div>
                                <p><strong>Total de dominios recolectados:</strong> {{.Domains.Total}}</p>
                                <p><strong>Dominios únicos:</strong> {{.Domains.Unique}} (registrables: {{.Domains.UniqueRegistrable}})</p>
                                <p><strong>Niveles promedio por dominio:</strong> {{printf "%.2f" .Domains.AverageLabels}}</p>
                        </div>
                        <div>
                                <p class="subtext">Los dominios con mayor frecuencia ayudan a identificar activos críticos y oportunidades para consolidar cobertura.</p>
                        </div>
                </div>
                {{if hasData .Domains.TopRegistrable}}
                <h3>Top dominios registrables</h3>
                <table>
                        <tr><th>Dominio</th><th>Conteo</th></tr>
                        {{range .Domains.TopRegistrable}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Domains.LabelHistogram}}
                <h3>Distribución por niveles</h3>
                <table>
                        <tr><th>Niveles</th><th>Conteo</th></tr>
                        {{range .Domains.LabelHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
        </section>

        <section>
                <h2>Rutas</h2>
                <div class="grid">
                        <div>
                                <p><strong>Total de rutas:</strong> {{.Routes.Total}}</p>
                                <p><strong>Hosts únicos observados:</strong> {{.Routes.UniqueHosts}}</p>
                                <p><strong>Profundidad promedio de ruta:</strong> {{printf "%.2f" .Routes.AveragePathDepth}}</p>
                        </div>
                        <div>
                                <p><strong>Uso de HTTPS:</strong> {{printf "%.1f" .Routes.SecurePercentage}}% de las rutas.</p>
                                <p><strong>Esquemas únicos:</strong> {{.Routes.UniqueSchemes}}</p>
                        </div>
                </div>
                {{if hasData .Routes.TopHosts}}
                <h3>Top hosts</h3>
                <table>
                        <tr><th>Host</th><th>Conteo</th></tr>
                        {{range .Routes.TopHosts}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.SchemeHistogram}}
                <h3>Esquemas por volumen</h3>
                <table>
                        <tr><th>Esquema</th><th>Conteo</th></tr>
                        {{range .Routes.SchemeHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.DepthHistogram}}
                <h3>Profundidad de rutas</h3>
                <table>
                        <tr><th>Segmentos</th><th>Conteo</th></tr>
                        {{range .Routes.DepthHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
        </section>

        <section>
                <h2>Certificados</h2>
                <div class="grid">
                        <div>
                                <p><strong>Total de certificados recolectados:</strong> {{.Certificates.Total}}</p>
                                <p><strong>Certificados únicos:</strong> {{.Certificates.Unique}}</p>
                        </div>
                        <div>
                                <p><strong>Dominios registrables únicos:</strong> {{.Certificates.UniqueRegistrable}}</p>
                                <p class="subtext">Útiles para validar el alcance de la emisión y reutilización de certificados.</p>
                        </div>
                </div>
                {{if hasData .Certificates.TopRegistrable}}
                <h3>Top dominios registrables</h3>
                <table>
                        <tr><th>Dominio</th><th>Conteo</th></tr>
                        {{range .Certificates.TopRegistrable}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
        </section>

        <section>
                <h2>Meta</h2>
                {{if .Meta}}
                <ul>
                        {{range .Meta}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{else}}
                <p class="muted">Sin entradas meta.</p>
                {{end}}
        </section>
</body>
</html>`
