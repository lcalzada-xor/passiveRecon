package report

import (
	"context"
	"errors"
	"fmt"
	"html/template"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"passive-rec/internal/config"
)

// SinkFiles describe the location of the files generated by the sink.
type SinkFiles struct {
	Domains string
	Routes  string
	Certs   string
	Meta    string
}

// DefaultSinkFiles returns the expected sink file paths within outDir.
func DefaultSinkFiles(outDir string) SinkFiles {
	return SinkFiles{
		Domains: filepath.Join(outDir, "domains.passive"),
		Routes:  filepath.Join(outDir, "routes.passive"),
		Certs:   filepath.Join(outDir, "certs.passive"),
		Meta:    filepath.Join(outDir, "meta.passive"),
	}
}

// Generate reads the passive sink files and renders an HTML report in cfg.OutDir.
func Generate(ctx context.Context, cfg *config.Config, files SinkFiles) error {
	if cfg == nil {
		return errors.New("report: missing config")
	}
	if err := ctx.Err(); err != nil {
		return err
	}

	domains, err := readLines(ctx, files.Domains)
	if err != nil {
		return fmt.Errorf("report: domains: %w", err)
	}
	routes, err := readLines(ctx, files.Routes)
	if err != nil {
		return fmt.Errorf("report: routes: %w", err)
	}
	certs, err := readLines(ctx, files.Certs)
	if err != nil {
		return fmt.Errorf("report: certs: %w", err)
	}
	meta, err := readLines(ctx, files.Meta)
	if err != nil {
		return fmt.Errorf("report: meta: %w", err)
	}

	data := reportData{
		Target:       cfg.Target,
		OutDir:       cfg.OutDir,
		GeneratedAt:  time.Now().Format(time.RFC3339),
		Domains:      buildDomainStats(domains),
		Routes:       buildRouteStats(routes),
		Certificates: buildCertStats(certs),
		Meta:         meta,
	}

	reportPath := filepath.Join(cfg.OutDir, "report.html")
	if err := ctx.Err(); err != nil {
		return err
	}

	f, err := os.Create(reportPath)
	if err != nil {
		return fmt.Errorf("report: create %q: %w", reportPath, err)
	}
	defer f.Close()

	if err := reportTmpl.Execute(f, data); err != nil {
		return fmt.Errorf("report: render: %w", err)
	}
	return nil
}

type countItem struct {
	Name  string
	Count int
}

type domainStats struct {
	Total          int
	TopRegistrable []countItem
	LabelHistogram []countItem
}

type routeStats struct {
	Total            int
	TopHosts         []countItem
	SchemeHistogram  []countItem
	DepthHistogram   []countItem
	AveragePathDepth float64
}

type certStats struct {
	Total          int
	TopRegistrable []countItem
}

type reportData struct {
	Target       string
	OutDir       string
	GeneratedAt  string
	Domains      domainStats
	Routes       routeStats
	Certificates certStats
	Meta         []string
}

const topN = 10

var reportTmpl = template.Must(template.New("report").Funcs(template.FuncMap{
	"hasData": func(items []countItem) bool { return len(items) > 0 },
}).Parse(reportTemplate))

func readLines(ctx context.Context, path string) ([]string, error) {
	if path == "" {
		return nil, nil
	}
	if err := ctx.Err(); err != nil {
		return nil, err
	}
	data, err := os.ReadFile(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil, nil
		}
		return nil, err
	}
	contents := strings.TrimSpace(string(data))
	if contents == "" {
		return nil, nil
	}
	lines := strings.Split(contents, "\n")
	for i, ln := range lines {
		lines[i] = strings.TrimSpace(ln)
	}
	return lines, nil
}

func buildDomainStats(domains []string) domainStats {
	stats := domainStats{Total: len(domains)}
	if len(domains) == 0 {
		return stats
	}
	registrableCounts := make(map[string]int)
	labelHistogram := make(map[string]int)
	for _, d := range domains {
		if d == "" {
			continue
		}
		registrableCounts[registrableDomain(d)]++
		labelKey := fmt.Sprintf("%d niveles", strings.Count(d, ".")+1)
		labelHistogram[labelKey]++
	}
	stats.TopRegistrable = topItems(registrableCounts, topN)
	stats.LabelHistogram = topItems(labelHistogram, len(labelHistogram))
	return stats
}

func buildCertStats(certs []string) certStats {
	stats := certStats{Total: len(certs)}
	if len(certs) == 0 {
		return stats
	}
	registrableCounts := make(map[string]int)
	for _, c := range certs {
		if c == "" {
			continue
		}
		registrableCounts[registrableDomain(c)]++
	}
	stats.TopRegistrable = topItems(registrableCounts, topN)
	return stats
}

func buildRouteStats(routes []string) routeStats {
	stats := routeStats{Total: len(routes)}
	if len(routes) == 0 {
		return stats
	}
	hostCounts := make(map[string]int)
	schemeHistogram := make(map[string]int)
	depthHistogram := make(map[string]int)
	var totalDepth int
	for _, raw := range routes {
		trimmed := strings.TrimSpace(raw)
		if trimmed == "" {
			continue
		}
		fields := strings.Fields(trimmed)
		candidate := trimmed
		if len(fields) > 0 {
			candidate = fields[0]
		}
		u, err := url.Parse(candidate)
		if err != nil {
			continue
		}
		host := strings.TrimSpace(u.Host)
		if host == "" {
			host = "(sin host)"
		}
		hostCounts[strings.ToLower(host)]++
		scheme := strings.ToLower(u.Scheme)
		if scheme == "" {
			scheme = "(vacÃ­o)"
		}
		schemeHistogram[scheme]++
		path := strings.Trim(u.Path, "/")
		depth := 0
		if path != "" {
			depth = len(strings.Split(path, "/"))
		}
		depthKey := fmt.Sprintf("%d segmentos", depth)
		depthHistogram[depthKey]++
		totalDepth += depth
	}
	stats.TopHosts = topItems(hostCounts, topN)
	stats.SchemeHistogram = topItems(schemeHistogram, len(schemeHistogram))
	stats.DepthHistogram = topItems(depthHistogram, len(depthHistogram))
	stats.AveragePathDepth = float64(totalDepth)
	if stats.Total > 0 {
		stats.AveragePathDepth = stats.AveragePathDepth / float64(stats.Total)
	}
	return stats
}

func registrableDomain(domain string) string {
	parts := strings.FieldsFunc(domain, func(r rune) bool { return r == '.' })
	if len(parts) <= 1 {
		return strings.ToLower(strings.TrimSpace(domain))
	}
	last := parts[len(parts)-1]
	secondLast := parts[len(parts)-2]
	if secondLast == "" {
		return strings.ToLower(last)
	}
	return strings.ToLower(secondLast + "." + last)
}

func topItems(counts map[string]int, n int) []countItem {
	if len(counts) == 0 || n == 0 {
		return nil
	}
	items := make([]countItem, 0, len(counts))
	for name, count := range counts {
		items = append(items, countItem{Name: name, Count: count})
	}
	sort.Slice(items, func(i, j int) bool {
		if items[i].Count == items[j].Count {
			return items[i].Name < items[j].Name
		}
		return items[i].Count > items[j].Count
	})
	if n > len(items) {
		n = len(items)
	}
	return items[:n]
}

const reportTemplate = `<!DOCTYPE html>
<html lang="es">
<head>
        <meta charset="utf-8">
        <title>Informe passive-rec</title>
        <style>
                body { font-family: Arial, sans-serif; margin: 2rem; background: #f7f7f7; color: #222; }
                h1, h2, h3 { color: #1f2937; }
                table { border-collapse: collapse; margin-bottom: 1.5rem; width: 100%; max-width: 800px; background: white; }
                th, td { border: 1px solid #ddd; padding: 0.5rem 0.75rem; text-align: left; }
                th { background: #0f172a; color: white; }
                section { margin-bottom: 2rem; padding: 1rem; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
                ul { padding-left: 1.5rem; }
                .muted { color: #6b7280; }
        </style>
</head>
<body>
        <h1>Informe de passive-rec</h1>
        <p><strong>Objetivo:</strong> {{.Target}}</p>
        <p><strong>Directorio de salida:</strong> {{.OutDir}}</p>
        <p class="muted">Generado: {{.GeneratedAt}}</p>

        <section>
                <h2>Dominios</h2>
                <p>Total: {{.Domains.Total}}</p>
                {{if hasData .Domains.TopRegistrable}}
                <h3>Top dominios registrables</h3>
                <table>
                        <tr><th>Dominio</th><th>Conteo</th></tr>
                        {{range .Domains.TopRegistrable}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Domains.LabelHistogram}}
                <h3>Histograma por niveles</h3>
                <table>
                        <tr><th>Niveles</th><th>Conteo</th></tr>
                        {{range .Domains.LabelHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
        </section>

        <section>
                <h2>Rutas</h2>
                <p>Total: {{.Routes.Total}}</p>
                <p>Profundidad promedio de ruta: {{printf "%.2f" .Routes.AveragePathDepth}}</p>
                {{if hasData .Routes.TopHosts}}
                <h3>Top hosts</h3>
                <table>
                        <tr><th>Host</th><th>Conteo</th></tr>
                        {{range .Routes.TopHosts}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.SchemeHistogram}}
                <h3>Esquemas</h3>
                <table>
                        <tr><th>Esquema</th><th>Conteo</th></tr>
                        {{range .Routes.SchemeHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.DepthHistogram}}
                <h3>Profundidad de ruta</h3>
                <table>
                        <tr><th>Segmentos</th><th>Conteo</th></tr>
                        {{range .Routes.DepthHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
        </section>

        <section>
                <h2>Certificados</h2>
                <p>Total: {{.Certificates.Total}}</p>
                {{if hasData .Certificates.TopRegistrable}}
                <h3>Top dominios registrables</h3>
                <table>
                        <tr><th>Dominio</th><th>Conteo</th></tr>
                        {{range .Certificates.TopRegistrable}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
        </section>

        <section>
                <h2>Meta</h2>
                {{if .Meta}}
                <ul>
                        {{range .Meta}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{else}}
                <p class="muted">Sin entradas meta.</p>
                {{end}}
        </section>
</body>
</html>`
