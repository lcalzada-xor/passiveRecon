package report

import (
	"context"
	"errors"
	"fmt"
	"html/template"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"golang.org/x/net/publicsuffix"

	"passive-rec/internal/certs"
	"passive-rec/internal/config"
)

// SinkFiles describe the location of the files generated by the sink.
type SinkFiles struct {
	Domains string
	Routes  string
	Certs   string
	Meta    string
}

// DefaultSinkFiles returns the expected sink file paths within outDir.
func DefaultSinkFiles(outDir string) SinkFiles {
	return SinkFiles{
		Domains: filepath.Join(outDir, "domains", "domains.passive"),
		Routes:  filepath.Join(outDir, "routes", "routes.passive"),
		Certs:   filepath.Join(outDir, "certs", "certs.passive"),
		Meta:    filepath.Join(outDir, "meta.passive"),
	}
}

// Generate reads the passive sink files and renders an HTML report in cfg.OutDir.
func Generate(ctx context.Context, cfg *config.Config, files SinkFiles) error {
	if cfg == nil {
		return errors.New("report: missing config")
	}
	if err := ctx.Err(); err != nil {
		return err
	}

	domains, err := readLines(ctx, files.Domains)
	if err != nil {
		return fmt.Errorf("report: domains: %w", err)
	}
	routes, err := readLines(ctx, files.Routes)
	if err != nil {
		return fmt.Errorf("report: routes: %w", err)
	}
	certs, err := readLines(ctx, files.Certs)
	if err != nil {
		return fmt.Errorf("report: certs: %w", err)
	}
	meta, err := readLines(ctx, files.Meta)
	if err != nil {
		return fmt.Errorf("report: meta: %w", err)
	}

	domainStats := buildDomainStats(domains)
	routeStats := buildRouteStats(routes)
	certStats := buildCertStats(certs)

	data := reportData{
		Target:      cfg.Target,
		OutDir:      cfg.OutDir,
		GeneratedAt: time.Now().Format(time.RFC3339),
		Overview: overviewStats{
			TotalArtifacts:        domainStats.Total + routeStats.Total + certStats.Total,
			UniqueDomains:         domainStats.Unique,
			UniqueHosts:           routeStats.UniqueHosts,
			UniqueCertificates:    certStats.Unique,
			SecureRoutesPercent:   routeStats.SecurePercentage,
			InsecureRoutesPercent: 100 - routeStats.SecurePercentage,
		},
		Domains:      domainStats,
		Routes:       routeStats,
		Certificates: certStats,
		Meta:         meta,
		Highlights:   buildHighlights(domainStats, routeStats, certStats),
	}

	reportPath := filepath.Join(cfg.OutDir, "report.html")
	if err := ctx.Err(); err != nil {
		return err
	}

	f, err := os.Create(reportPath)
	if err != nil {
		return fmt.Errorf("report: create %q: %w", reportPath, err)
	}
	defer f.Close()

	if err := reportTmpl.Execute(f, data); err != nil {
		return fmt.Errorf("report: render: %w", err)
	}
	return nil
}

type countItem struct {
	Name  string
	Count int
}

type domainStats struct {
	Total             int
	Unique            int
	UniqueRegistrable int
	AverageLabels     float64
	TopRegistrable    []countItem
	LabelHistogram    []countItem
	TopTLDs           []countItem
	WildcardCount     int
	Interesting       []string
}

type routeStats struct {
	Total             int
	UniqueHosts       int
	UniqueSchemes     int
	SecurePercentage  float64
	TopHosts          []countItem
	SchemeHistogram   []countItem
	DepthHistogram    []countItem
	AveragePathDepth  float64
	InsecureHosts     []countItem
	InsecureHostTotal int
	TopPorts          []countItem
	InterestingPaths  []string
	NonStandardPorts  []string
}

type certStats struct {
	Total             int
	Unique            int
	UniqueRegistrable int
	UniqueIssuers     int
	Expired           int
	ExpiringSoon      int
	SoonThresholdDays int
	NextExpiration    string
	LatestExpiration  string
	TopRegistrable    []countItem
	TopIssuers        []countItem
	ExpiringSoonList  []string
	ExpiredList       []string
}

type overviewStats struct {
	TotalArtifacts        int
	UniqueDomains         int
	UniqueHosts           int
	UniqueCertificates    int
	SecureRoutesPercent   float64
	InsecureRoutesPercent float64
}

type reportData struct {
	Target       string
	OutDir       string
	GeneratedAt  string
	Overview     overviewStats
	Domains      domainStats
	Routes       routeStats
	Certificates certStats
	Meta         []string
	Highlights   []string
}

const (
	topN               = 10
	certExpirySoonDays = 30
	maxInterestingRows = 10
)

var certTimeLayouts = []string{
	time.RFC3339Nano,
	time.RFC3339,
	"2006-01-02T15:04:05",
	"2006-01-02 15:04:05",
	"2006-01-02",
}

var reportTmpl = template.Must(template.New("report").Funcs(template.FuncMap{
	"hasData":    func(items []countItem) bool { return len(items) > 0 },
	"hasStrings": func(items []string) bool { return len(items) > 0 },
}).Parse(reportTemplate))

var (
	interestingDomainKeywords = []string{
		"admin", "portal", "intranet", "vpn", "dev", "test", "stage", "staging", "qa", "beta", "login", "sso", "auth", "api", "secure", "internal", "manage", "ops", "billing", "payments",
	}
	interestingRouteKeywords = []string{
		"admin", "login", "portal", "debug", "backup", "dev", "test", "stage", "config", "console", "manage", "git", "jenkins", "api", "token", "sso", "callback",
	}
)

func readLines(ctx context.Context, path string) ([]string, error) {
	if path == "" {
		return nil, nil
	}
	if err := ctx.Err(); err != nil {
		return nil, err
	}
	data, err := os.ReadFile(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil, nil
		}
		return nil, err
	}
	contents := strings.TrimSpace(string(data))
	if contents == "" {
		return nil, nil
	}
	lines := strings.Split(contents, "\n")
	for i, ln := range lines {
		lines[i] = strings.TrimSpace(ln)
	}
	return lines, nil
}

func buildDomainStats(domains []string) domainStats {
	stats := domainStats{}
	if len(domains) == 0 {
		return stats
	}
	registrableCounts := make(map[string]int)
	labelHistogram := make(map[string]int)
	tldCounts := make(map[string]int)
	uniqueDomains := make(map[string]struct{})
	uniqueRegistrable := make(map[string]struct{})
	interesting := make(map[string]struct{})
	var totalLabels int
	for _, raw := range domains {
		d := strings.TrimSpace(raw)
		if d == "" {
			continue
		}
		lowered := strings.ToLower(d)
		stats.Total++
		uniqueDomains[lowered] = struct{}{}
		if strings.HasPrefix(strings.TrimSpace(raw), "*.") {
			stats.WildcardCount++
		}
		registrable := registrableDomain(d)
		if registrable != "" {
			uniqueRegistrable[registrable] = struct{}{}
			registrableCounts[registrable]++
		}
		if suffix, _ := publicsuffix.PublicSuffix(lowered); suffix != "" {
			tldCounts[suffix]++
		} else {
			parts := strings.Split(lowered, ".")
			if len(parts) > 0 {
				tldCounts[parts[len(parts)-1]]++
			}
		}
		levels := strings.Count(lowered, ".") + 1
		labelKey := fmt.Sprintf("%d niveles", levels)
		labelHistogram[labelKey]++
		totalLabels += levels
		for _, keyword := range interestingDomainKeywords {
			if strings.Contains(lowered, keyword) {
				interesting[lowered] = struct{}{}
				break
			}
		}
	}
	stats.TopRegistrable = topItems(registrableCounts, topN)
	stats.LabelHistogram = topItems(labelHistogram, len(labelHistogram))
	stats.TopTLDs = topItems(tldCounts, topN)
	stats.Unique = len(uniqueDomains)
	stats.UniqueRegistrable = len(uniqueRegistrable)
	if len(interesting) > 0 {
		stats.Interesting = sortedStringsWithLimit(interesting, maxInterestingRows)
	}
	if stats.Total > 0 {
		stats.AverageLabels = float64(totalLabels) / float64(stats.Total)
	}
	return stats
}

func buildCertStats(certsLines []string) certStats {
	return buildCertStatsAt(certsLines, time.Now())
}

func buildCertStatsAt(certsLines []string, now time.Time) certStats {
	stats := certStats{SoonThresholdDays: certExpirySoonDays}
	if len(certsLines) == 0 {
		return stats
	}
	registrableCounts := make(map[string]int)
	issuerCounts := make(map[string]int)
	uniqueCerts := make(map[string]struct{})
	uniqueRegistrable := make(map[string]struct{})
	uniqueIssuers := make(map[string]struct{})
	expiringSoon := make(map[string]struct{})
	expired := make(map[string]struct{})
	var nextExpiration time.Time
	var latestExpiration time.Time
	for _, raw := range certsLines {
		record, err := certs.Parse(raw)
		if err != nil {
			continue
		}
		stats.Total++
		key := record.Key()
		if key == "" {
			key = strings.TrimSpace(strings.ToLower(raw))
		}
		uniqueCerts[key] = struct{}{}
		issuer := strings.TrimSpace(record.Issuer)
		if issuer != "" {
			issuerCounts[issuer]++
			uniqueIssuers[strings.ToLower(issuer)] = struct{}{}
		}
		for _, name := range record.AllNames() {
			registrable := registrableDomain(name)
			if registrable == "" {
				continue
			}
			uniqueRegistrable[registrable] = struct{}{}
			registrableCounts[registrable]++
		}
		if expiry := parseCertTime(record.NotAfter); !expiry.IsZero() {
			displayName := certDisplayName(record)
			if expiry.Before(now) {
				stats.Expired++
				if displayName != "" {
					expired[fmt.Sprintf("%s (venció %s)", displayName, expiry.Format("2006-01-02"))] = struct{}{}
				}
				continue
			}
			if expiry.Sub(now) <= certExpirySoonWindow() {
				stats.ExpiringSoon++
				if displayName != "" {
					expiringSoon[fmt.Sprintf("%s (vence %s)", displayName, expiry.Format("2006-01-02"))] = struct{}{}
				}
			}
			if nextExpiration.IsZero() || expiry.Before(nextExpiration) {
				nextExpiration = expiry
			}
			if latestExpiration.IsZero() || expiry.After(latestExpiration) {
				latestExpiration = expiry
			}
		}
	}
	stats.TopRegistrable = topItems(registrableCounts, topN)
	stats.TopIssuers = topItems(issuerCounts, topN)
	stats.Unique = len(uniqueCerts)
	stats.UniqueRegistrable = len(uniqueRegistrable)
	stats.UniqueIssuers = len(uniqueIssuers)
	if len(expiringSoon) > 0 {
		stats.ExpiringSoonList = sortedStringsWithLimit(expiringSoon, maxInterestingRows)
	}
	if len(expired) > 0 {
		stats.ExpiredList = sortedStringsWithLimit(expired, maxInterestingRows)
	}
	if !nextExpiration.IsZero() {
		stats.NextExpiration = nextExpiration.Format("2006-01-02")
	}
	if !latestExpiration.IsZero() {
		stats.LatestExpiration = latestExpiration.Format("2006-01-02")
	}
	return stats
}

func buildRouteStats(routes []string) routeStats {
	stats := routeStats{}
	if len(routes) == 0 {
		return stats
	}
	hostCounts := make(map[string]int)
	schemeHistogram := make(map[string]int)
	depthHistogram := make(map[string]int)
	insecureHostCounts := make(map[string]int)
	portCounts := make(map[string]int)
	interestingPaths := make(map[string]struct{})
	nonStandard := make(map[string]struct{})
	var totalDepth int
	uniqueHosts := make(map[string]struct{})
	httpsCount := 0
	for _, raw := range routes {
		trimmed := strings.TrimSpace(raw)
		if trimmed == "" {
			continue
		}
		fields := strings.Fields(trimmed)
		candidate := trimmed
		if len(fields) > 0 {
			candidate = fields[0]
		}
		u, err := url.Parse(candidate)
		if err != nil {
			continue
		}
		stats.Total++
		host := strings.TrimSpace(u.Host)
		if host == "" {
			host = "(sin host)"
		}
		loweredHost := strings.ToLower(host)
		hostCounts[loweredHost]++
		uniqueHosts[loweredHost] = struct{}{}
		rawScheme := strings.ToLower(u.Scheme)
		scheme := rawScheme
		if scheme == "" {
			scheme = "(vacío)"
		}
		schemeHistogram[scheme]++
		if rawScheme == "https" {
			httpsCount++
		} else if rawScheme != "" {
			hostname := strings.ToLower(u.Hostname())
			if hostname != "" {
				insecureHostCounts[hostname]++
			}
		}
		path := strings.Trim(u.Path, "/")
		depth := 0
		if path != "" {
			depth = len(strings.Split(path, "/"))
		}
		depthKey := fmt.Sprintf("%d segmentos", depth)
		depthHistogram[depthKey]++
		totalDepth += depth
		port := u.Port()
		if port == "" {
			if def := defaultPortForScheme(rawScheme); def != "" {
				port = def
			}
		}
		displayPort := port
		if displayPort == "" {
			displayPort = "(sin puerto)"
		}
		portCounts[displayPort]++
		if port != "" && isNonStandardPort(rawScheme, port) {
			endpointScheme := rawScheme
			if endpointScheme == "" {
				endpointScheme = scheme
			}
			endpoint := fmt.Sprintf("%s://%s", endpointScheme, host)
			nonStandard[strings.ToLower(endpoint)] = struct{}{}
		}
		loweredCandidate := strings.ToLower(candidate)
		for _, keyword := range interestingRouteKeywords {
			if strings.Contains(loweredCandidate, keyword) {
				normalized := candidate
				if u.Scheme != "" && u.Host != "" {
					normalized = u.Scheme + "://" + u.Host + u.Path
					if u.RawQuery != "" {
						normalized += "?" + u.RawQuery
					}
				} else if normalized == "" {
					normalized = fmt.Sprintf("%s://%s", rawScheme, host)
				}
				interestingPaths[normalized] = struct{}{}
				break
			}
		}
	}
	stats.TopHosts = topItems(hostCounts, topN)
	stats.SchemeHistogram = topItems(schemeHistogram, len(schemeHistogram))
	stats.DepthHistogram = topItems(depthHistogram, len(depthHistogram))
	stats.AveragePathDepth = float64(totalDepth)
	stats.UniqueHosts = len(uniqueHosts)
	stats.UniqueSchemes = len(schemeHistogram)
	if len(insecureHostCounts) > 0 {
		stats.InsecureHosts = topItems(insecureHostCounts, topN)
		stats.InsecureHostTotal = len(insecureHostCounts)
	}
	if len(portCounts) > 0 {
		stats.TopPorts = topItems(portCounts, len(portCounts))
	}
	if len(interestingPaths) > 0 {
		stats.InterestingPaths = sortedStringsWithLimit(interestingPaths, maxInterestingRows)
	}
	if len(nonStandard) > 0 {
		stats.NonStandardPorts = sortedStringsWithLimit(nonStandard, maxInterestingRows)
	}
	if stats.Total > 0 {
		stats.AveragePathDepth = stats.AveragePathDepth / float64(stats.Total)
		stats.SecurePercentage = (float64(httpsCount) / float64(stats.Total)) * 100
	}
	return stats
}

func registrableDomain(domain string) string {
	trimmed := strings.TrimSpace(domain)
	if trimmed == "" {
		return ""
	}
	cleaned := strings.ToLower(strings.TrimSuffix(trimmed, "."))
	cleaned = strings.TrimPrefix(cleaned, "*.")
	if cleaned == "" {
		return ""
	}
	registrable, err := publicsuffix.EffectiveTLDPlusOne(cleaned)
	if err != nil {
		return cleaned
	}
	return strings.ToLower(registrable)
}

func topItems(counts map[string]int, n int) []countItem {
	if len(counts) == 0 || n == 0 {
		return nil
	}
	items := make([]countItem, 0, len(counts))
	for name, count := range counts {
		items = append(items, countItem{Name: name, Count: count})
	}
	sort.Slice(items, func(i, j int) bool {
		if items[i].Count == items[j].Count {
			return items[i].Name < items[j].Name
		}
		return items[i].Count > items[j].Count
	})
	if n > len(items) {
		n = len(items)
	}
	return items[:n]
}

func parseCertTime(value string) time.Time {
	value = strings.TrimSpace(value)
	if value == "" {
		return time.Time{}
	}
	for _, layout := range certTimeLayouts {
		if t, err := time.Parse(layout, value); err == nil {
			return t.UTC()
		}
	}
	return time.Time{}
}

func certExpirySoonWindow() time.Duration {
	return time.Duration(certExpirySoonDays) * 24 * time.Hour
}

func sortedStringsWithLimit(m map[string]struct{}, limit int) []string {
	out := make([]string, 0, len(m))
	for value := range m {
		out = append(out, value)
	}
	sort.Strings(out)
	if limit > 0 && len(out) > limit {
		out = out[:limit]
	}
	return out
}

func defaultPortForScheme(scheme string) string {
	switch scheme {
	case "http":
		return "80"
	case "https":
		return "443"
	case "ssh":
		return "22"
	case "ftp":
		return "21"
	case "rdp":
		return "3389"
	}
	return ""
}

func isNonStandardPort(scheme, port string) bool {
	if scheme == "" || port == "" {
		return false
	}
	def := defaultPortForScheme(scheme)
	if def == "" {
		return false
	}
	return port != def
}

func certDisplayName(record certs.Record) string {
	if record.CommonName != "" {
		return record.CommonName
	}
	if len(record.DNSNames) > 0 {
		return record.DNSNames[0]
	}
	if record.Subject != "" {
		return record.Subject
	}
	return ""
}

func limitStrings(values []string, max int) []string {
	if max <= 0 || len(values) <= max {
		return values
	}
	return values[:max]
}

func buildHighlights(domains domainStats, routes routeStats, certs certStats) []string {
	var highlights []string
	if routes.SecurePercentage < 100 {
		if len(routes.InsecureHosts) > 0 {
			count := routes.InsecureHostTotal
			verb := "exponen"
			noun := "hosts"
			if count == 1 {
				verb = "expone"
				noun = "host"
			}
			highlights = append(highlights, fmt.Sprintf("%d %s %s servicios sin HTTPS (por ejemplo %s)", count, noun, verb, routes.InsecureHosts[0].Name))
		} else {
			highlights = append(highlights, fmt.Sprintf("%.1f%% de las rutas carecen de HTTPS", 100-routes.SecurePercentage))
		}
	}
	if len(routes.NonStandardPorts) > 0 {
		highlights = append(highlights, fmt.Sprintf("Servicios en puertos no estándar detectados: %s", strings.Join(limitStrings(routes.NonStandardPorts, 3), ", ")))
	}
	if len(routes.InterestingPaths) > 0 {
		highlights = append(highlights, fmt.Sprintf("Endpoints potencialmente sensibles encontrados (ej. %s)", routes.InterestingPaths[0]))
	}
	if len(domains.Interesting) > 0 {
		highlights = append(highlights, fmt.Sprintf("Dominios que sugieren entornos sensibles: %s", strings.Join(limitStrings(domains.Interesting, 3), ", ")))
	}
	if certs.Expired > 0 {
		if len(certs.ExpiredList) > 0 {
			highlights = append(highlights, fmt.Sprintf("%d certificados vencidos, incluyendo %s", certs.Expired, certs.ExpiredList[0]))
		} else {
			highlights = append(highlights, fmt.Sprintf("%d certificados vencidos detectados", certs.Expired))
		}
	}
	if certs.ExpiringSoon > 0 {
		if len(certs.ExpiringSoonList) > 0 {
			highlights = append(highlights, fmt.Sprintf("%d certificados por expirar pronto (ej. %s)", certs.ExpiringSoon, certs.ExpiringSoonList[0]))
		} else {
			highlights = append(highlights, fmt.Sprintf("%d certificados por expirar en %d días", certs.ExpiringSoon, certExpirySoonDays))
		}
	}
	return highlights
}

const reportTemplate = `<!DOCTYPE html>
<html lang="es">
<head>
        <meta charset="utf-8">
        <title>Informe passive-rec</title>
        <style>
                :root {
                        color-scheme: light;
                }
                body { font-family: "Inter", "Segoe UI", Arial, sans-serif; margin: 2.5rem; background: #f1f5f9; color: #1f2937; }
                h1, h2, h3 { color: #111827; margin-top: 0; }
                header { margin-bottom: 2rem; }
                section { margin-bottom: 2rem; padding: 1.5rem; background: #ffffff; border-radius: 12px; box-shadow: 0 15px 35px rgba(15, 23, 42, 0.08); }
                table { border-collapse: collapse; margin-bottom: 1.5rem; width: 100%; background: white; border-radius: 8px; overflow: hidden; }
                th, td { border: 1px solid #e2e8f0; padding: 0.65rem 0.9rem; text-align: left; }
                th { background: #0f172a; color: #f8fafc; text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.82rem; }
                ul { padding-left: 1.5rem; }
                .muted { color: #64748b; }
                .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; margin-top: 1rem; }
                .card { border: 1px solid #e2e8f0; border-radius: 10px; padding: 1rem; background: linear-gradient(135deg, rgba(148, 163, 184, 0.12), rgba(148, 163, 184, 0)); }
                .metric { font-size: 2rem; font-weight: 600; color: #0f172a; margin: 0.25rem 0; }
                .subtext { font-size: 0.9rem; color: #475569; margin: 0; }
                .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; }
        </style>
</head>
<body>
        <header>
                <h1>Informe de passive-rec</h1>
                <p><strong>Objetivo:</strong> {{.Target}}</p>
                <p><strong>Directorio de salida:</strong> {{.OutDir}}</p>
                <p class="muted">Generado: {{.GeneratedAt}}</p>
        </header>

        <section>
                <h2>Resumen ejecutivo</h2>
                <p class="subtext">Vista rápida de los hallazgos más relevantes para priorizar acciones.</p>
                <div class="cards">
                        <div class="card">
                                <h3>Total de artefactos procesados</h3>
                                <p class="metric">{{.Overview.TotalArtifacts}}</p>
                                <p class="subtext">Entradas combinadas de dominios, rutas y certificados.</p>
                        </div>
                        <div class="card">
                                <h3>Dominios únicos</h3>
                                <p class="metric">{{.Overview.UniqueDomains}}</p>
                                <p class="subtext">Incluye {{.Domains.UniqueRegistrable}} dominios registrables distintos.</p>
                        </div>
                        <div class="card">
                                <h3>Hosts únicos en rutas</h3>
                                <p class="metric">{{.Overview.UniqueHosts}}</p>
                                <p class="subtext">Cobertura sobre {{.Routes.UniqueSchemes}} esquemas de servicio; {{printf "%.1f" .Overview.InsecureRoutesPercent}}% sin HTTPS.</p>
                        </div>
                        <div class="card">
                                <h3>Certificados únicos</h3>
                                <p class="metric">{{.Overview.UniqueCertificates}}</p>
                                <p class="subtext">{{.Certificates.ExpiringSoon}} por expirar en {{.Certificates.SoonThresholdDays}} días.</p>
                        </div>
                </div>
        </section>

        <section>
                <h2>Hallazgos clave</h2>
                {{if hasStrings .Highlights}}
                <ul>
                        {{range .Highlights}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{else}}
                <p class="muted">Sin hallazgos destacados generados automáticamente.</p>
                {{end}}
        </section>

        <section>
                <h2>Dominios</h2>
                <div class="grid">
                        <div>
                                <p><strong>Total de dominios recolectados:</strong> {{.Domains.Total}}</p>
                                <p><strong>Dominios únicos:</strong> {{.Domains.Unique}} (registrables: {{.Domains.UniqueRegistrable}})</p>
                                <p><strong>Niveles promedio por dominio:</strong> {{printf "%.2f" .Domains.AverageLabels}}</p>
                                <p><strong>Dominios comodín detectados:</strong> {{.Domains.WildcardCount}}</p>
                        </div>
                        <div>
                                <p class="subtext">Los dominios con mayor frecuencia ayudan a identificar activos críticos y oportunidades para consolidar cobertura.</p>
                        </div>
                </div>
                {{if hasData .Domains.TopRegistrable}}
                <h3>Top dominios registrables</h3>
                <table>
                        <tr><th>Dominio</th><th>Conteo</th></tr>
                        {{range .Domains.TopRegistrable}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Domains.LabelHistogram}}
                <h3>Distribución por niveles</h3>
                <table>
                        <tr><th>Niveles</th><th>Conteo</th></tr>
                        {{range .Domains.LabelHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Domains.TopTLDs}}
                <h3>Top TLDs observados</h3>
                <table>
                        <tr><th>TLD</th><th>Conteo</th></tr>
                        {{range .Domains.TopTLDs}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasStrings .Domains.Interesting}}
                <h3>Dominios potencialmente sensibles</h3>
                <ul>
                        {{range .Domains.Interesting}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{end}}
        </section>

        <section>
                <h2>Rutas</h2>
                <div class="grid">
                        <div>
                                <p><strong>Total de rutas:</strong> {{.Routes.Total}}</p>
                                <p><strong>Hosts únicos observados:</strong> {{.Routes.UniqueHosts}}</p>
                                <p><strong>Profundidad promedio de ruta:</strong> {{printf "%.2f" .Routes.AveragePathDepth}}</p>
                        </div>
                        <div>
                                <p><strong>Uso de HTTPS:</strong> {{printf "%.1f" .Routes.SecurePercentage}}% de las rutas.</p>
                                <p><strong>Esquemas únicos:</strong> {{.Routes.UniqueSchemes}}</p>
                                <p><strong>Hosts con protocolos inseguros:</strong> {{.Routes.InsecureHostTotal}}</p>
                        </div>
                </div>
                {{if hasData .Routes.TopHosts}}
                <h3>Top hosts</h3>
                <table>
                        <tr><th>Host</th><th>Conteo</th></tr>
                        {{range .Routes.TopHosts}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.SchemeHistogram}}
                <h3>Esquemas por volumen</h3>
                <table>
                        <tr><th>Esquema</th><th>Conteo</th></tr>
                        {{range .Routes.SchemeHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.DepthHistogram}}
                <h3>Profundidad de rutas</h3>
                <table>
                        <tr><th>Segmentos</th><th>Conteo</th></tr>
                        {{range .Routes.DepthHistogram}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.InsecureHosts}}
                <h3>Hosts con tráfico no cifrado</h3>
                <table>
                        <tr><th>Host</th><th>Observaciones</th></tr>
                        {{range .Routes.InsecureHosts}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Routes.TopPorts}}
                <h3>Puertos observados</h3>
                <table>
                        <tr><th>Puerto</th><th>Conteo</th></tr>
                        {{range .Routes.TopPorts}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasStrings .Routes.NonStandardPorts}}
                <h3>Servicios en puertos no estándar</h3>
                <ul>
                        {{range .Routes.NonStandardPorts}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{end}}
                {{if hasStrings .Routes.InterestingPaths}}
                <h3>Endpoints con palabras clave sensibles</h3>
                <ul>
                        {{range .Routes.InterestingPaths}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{end}}
        </section>

        <section>
                <h2>Certificados</h2>
                <div class="grid">
                        <div>
                                <p><strong>Total de certificados recolectados:</strong> {{.Certificates.Total}}</p>
                                <p><strong>Certificados únicos:</strong> {{.Certificates.Unique}}</p>
                                <p><strong>Emisores únicos:</strong> {{.Certificates.UniqueIssuers}}</p>
                                <p><strong>Certificados vencidos:</strong> {{.Certificates.Expired}}</p>
                        </div>
                        <div>
                                <p><strong>Dominios registrables únicos:</strong> {{.Certificates.UniqueRegistrable}}</p>
                                <p><strong>Certificados por expirar ({{.Certificates.SoonThresholdDays}} días):</strong> {{.Certificates.ExpiringSoon}}</p>
                                {{if .Certificates.NextExpiration}}
                                <p><strong>Próximo vencimiento:</strong> {{.Certificates.NextExpiration}}</p>
                                {{end}}
                                {{if .Certificates.LatestExpiration}}
                                <p><strong>Último vencimiento observado:</strong> {{.Certificates.LatestExpiration}}</p>
                                {{end}}
                                <p class="subtext">Útiles para validar el alcance de la emisión y reutilización de certificados.</p>
                        </div>
                </div>
                {{if hasData .Certificates.TopRegistrable}}
                <h3>Top dominios registrables</h3>
                <table>
                        <tr><th>Dominio</th><th>Conteo</th></tr>
                        {{range .Certificates.TopRegistrable}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasData .Certificates.TopIssuers}}
                <h3>Top emisores</h3>
                <table>
                        <tr><th>Emisor</th><th>Conteo</th></tr>
                        {{range .Certificates.TopIssuers}}
                        <tr><td>{{.Name}}</td><td>{{.Count}}</td></tr>
                        {{end}}
                </table>
                {{end}}
                {{if hasStrings .Certificates.ExpiredList}}
                <h3>Certificados vencidos destacados</h3>
                <ul>
                        {{range .Certificates.ExpiredList}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{end}}
                {{if hasStrings .Certificates.ExpiringSoonList}}
                <h3>Certificados próximos a expirar</h3>
                <ul>
                        {{range .Certificates.ExpiringSoonList}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{end}}
        </section>

        <section>
                <h2>Meta</h2>
                {{if .Meta}}
                <ul>
                        {{range .Meta}}
                        <li>{{.}}</li>
                        {{end}}
                </ul>
                {{else}}
                <p class="muted">Sin entradas meta.</p>
                {{end}}
        </section>
</body>
</html>`
